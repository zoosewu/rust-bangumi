# Auto-Download Dispatch Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement the auto-download dispatch system where Core automatically dispatches download links to appropriate Downloaders after fetcher results are processed.

**Architecture:** Core detects URL type via Chain of Responsibility, matches to downloader capabilities via junction table, batch-dispatches links with cascade fallback, and polls status via DownloadScheduler.

**Tech Stack:** Rust, Diesel ORM, Axum, PostgreSQL, reqwest (HTTP client), tokio (async runtime)

---

### Task 1: Database Migration — download_type enum, downloader_capabilities table, schema changes

**Files:**
- Create: `core-service/migrations/2026-02-06-000001-auto-download-dispatch/up.sql`
- Create: `core-service/migrations/2026-02-06-000001-auto-download-dispatch/down.sql`
- Auto-generated: `core-service/src/schema.rs` (via `diesel migration run`)

**Step 1: Create migration SQL**

`up.sql`:
```sql
-- 1. Create download_type enum
CREATE TYPE download_type AS ENUM ('magnet', 'torrent', 'http');

-- 2. Add download_type to anime_links
ALTER TABLE anime_links ADD COLUMN download_type VARCHAR(20);

-- 3. Add module_id and torrent_hash to downloads, expand status constraint
ALTER TABLE downloads DROP CONSTRAINT IF EXISTS downloads_status_check;
ALTER TABLE downloads ADD COLUMN module_id INT REFERENCES service_modules(module_id);
ALTER TABLE downloads ADD COLUMN torrent_hash VARCHAR(255);
ALTER TABLE downloads ADD CONSTRAINT downloads_status_check
    CHECK (status IN ('pending', 'downloading', 'completed', 'failed', 'cancelled', 'downloader_error', 'no_downloader'));

-- 4. Create downloader_capabilities junction table
CREATE TABLE downloader_capabilities (
    module_id INT REFERENCES service_modules(module_id) ON DELETE CASCADE,
    download_type VARCHAR(20) NOT NULL,
    PRIMARY KEY (module_id, download_type)
);

-- 5. Indexes
CREATE INDEX idx_downloads_module_status ON downloads(module_id, status);
CREATE INDEX idx_downloads_torrent_hash ON downloads(torrent_hash);
CREATE INDEX idx_anime_links_download_type ON anime_links(download_type);
```

Note: Using VARCHAR(20) instead of custom PG enum for download_type columns to avoid Diesel enum complexity. The Rust enum enforces type safety.

`down.sql`:
```sql
DROP INDEX IF EXISTS idx_anime_links_download_type;
DROP INDEX IF EXISTS idx_downloads_torrent_hash;
DROP INDEX IF EXISTS idx_downloads_module_status;
DROP TABLE IF EXISTS downloader_capabilities;
ALTER TABLE downloads DROP CONSTRAINT IF EXISTS downloads_status_check;
ALTER TABLE downloads DROP COLUMN IF EXISTS torrent_hash;
ALTER TABLE downloads DROP COLUMN IF EXISTS module_id;
ALTER TABLE downloads ADD CONSTRAINT downloads_status_check CHECK (status IN ('pending', 'downloading', 'completed', 'failed'));
ALTER TABLE anime_links DROP COLUMN IF EXISTS download_type;
DROP TYPE IF EXISTS download_type;
```

**Step 2: Run migration**

```bash
cd /workspace/.worktrees/auto-download-dispatch && diesel migration run --database-url "$DATABASE_URL"
```

**Step 3: Update schema.rs** (auto-generated by diesel)

Verify `schema.rs` now includes `download_type` in `anime_links`, `module_id` + `torrent_hash` in `downloads`, and new `downloader_capabilities` table.

**Step 4: Commit**
```bash
git add -A && git commit -m "feat(db): add download_type, downloader_capabilities, expand downloads table"
```

---

### Task 2: Shared Crate — DownloadType enum, updated Capabilities, batch DTOs

**Files:**
- Modify: `shared/src/models.rs`
- Modify: `shared/src/lib.rs` (if needed)

**Step 1: Add DownloadType enum to shared/src/models.rs**

```rust
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum DownloadType {
    Magnet,
    Torrent,
    Http,
}

impl std::fmt::Display for DownloadType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DownloadType::Magnet => write!(f, "magnet"),
            DownloadType::Torrent => write!(f, "torrent"),
            DownloadType::Http => write!(f, "http"),
        }
    }
}
```

**Step 2: Update Capabilities struct**

```rust
pub struct Capabilities {
    pub fetch_endpoint: Option<String>,
    pub download_endpoint: Option<String>,
    pub sync_endpoint: Option<String>,
    #[serde(default)]
    pub supported_download_types: Vec<DownloadType>,
}
```

**Step 3: Add batch download DTOs to shared**

```rust
// === Batch Download DTOs ===
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BatchDownloadRequest {
    pub items: Vec<DownloadRequestItem>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DownloadRequestItem {
    pub url: String,
    pub save_path: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BatchDownloadResponse {
    pub results: Vec<DownloadResultItem>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DownloadResultItem {
    pub url: String,
    pub hash: Option<String>,
    pub status: String,  // "accepted" or "rejected"
    pub reason: Option<String>,
}

// === Batch Cancel DTOs ===
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BatchCancelRequest {
    pub hashes: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BatchCancelResponse {
    pub results: Vec<CancelResultItem>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CancelResultItem {
    pub hash: String,
    pub status: String,  // "cancelled" or "not_found"
}

// === Status Query DTOs ===
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StatusQueryResponse {
    pub statuses: Vec<DownloadStatusItem>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DownloadStatusItem {
    pub hash: String,
    pub status: String,  // "downloading", "completed", "error"
    pub progress: f64,
    pub size: u64,
}
```

**Step 4: Verify compilation**
```bash
cargo check -p shared
```

**Step 5: Commit**
```bash
git add -A && git commit -m "feat(shared): add DownloadType enum, batch download DTOs, update Capabilities"
```

---

### Task 3: Core Models — Update AnimeLink, Download, add DownloaderCapability model

**Files:**
- Modify: `core-service/src/models/db.rs`

**Step 1: Update AnimeLink and NewAnimeLink structs**

Add `download_type: Option<String>` field to both.

**Step 2: Update Download and NewDownload structs**

Add `module_id: Option<i32>` and `torrent_hash: Option<String>` to both.

**Step 3: Add DownloaderCapability model**

```rust
#[derive(Queryable, Selectable, Debug, Clone)]
#[diesel(table_name = crate::schema::downloader_capabilities)]
pub struct DownloaderCapability {
    pub module_id: i32,
    pub download_type: String,
}

#[derive(Insertable)]
#[diesel(table_name = crate::schema::downloader_capabilities)]
pub struct NewDownloaderCapability {
    pub module_id: i32,
    pub download_type: String,
}
```

**Step 4: Verify compilation**
```bash
cargo check -p core-service 2>&1 | head -50
```

**Step 5: Commit**
```bash
git add -A && git commit -m "feat(core): update models for download dispatch (AnimeLink, Download, DownloaderCapability)"
```

---

### Task 4: Core Service — Chain of Responsibility download type detector

**Files:**
- Create: `core-service/src/services/download_type_detector.rs`
- Modify: `core-service/src/services/mod.rs`

**Step 1: Write tests first**

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_detect_magnet() {
        assert_eq!(detect_download_type("magnet:?xt=urn:btih:abc123"), Some(DownloadType::Magnet));
    }

    #[test]
    fn test_detect_torrent_url() {
        assert_eq!(detect_download_type("https://example.com/file.torrent"), Some(DownloadType::Torrent));
    }

    #[test]
    fn test_detect_http() {
        assert_eq!(detect_download_type("https://example.com/download/123"), Some(DownloadType::Http));
    }

    #[test]
    fn test_detect_unknown() {
        assert_eq!(detect_download_type("ftp://example.com/file"), None);
    }

    #[test]
    fn test_magnet_takes_priority_over_http() {
        // magnet: URLs should not be detected as Http
        assert_eq!(detect_download_type("magnet:?xt=urn:btih:abc"), Some(DownloadType::Magnet));
    }

    #[test]
    fn test_torrent_takes_priority_over_http() {
        assert_eq!(detect_download_type("http://example.com/test.torrent"), Some(DownloadType::Torrent));
    }
}
```

**Step 2: Implement**

```rust
use shared::DownloadType;

trait DownloadTypeDetector {
    fn detect(&self, url: &str) -> Option<DownloadType>;
}

struct MagnetDetector;
impl DownloadTypeDetector for MagnetDetector {
    fn detect(&self, url: &str) -> Option<DownloadType> {
        url.starts_with("magnet:").then_some(DownloadType::Magnet)
    }
}

struct TorrentDetector;
impl DownloadTypeDetector for TorrentDetector {
    fn detect(&self, url: &str) -> Option<DownloadType> {
        (url.starts_with("http") && url.contains(".torrent"))
            .then_some(DownloadType::Torrent)
    }
}

struct HttpDetector;
impl DownloadTypeDetector for HttpDetector {
    fn detect(&self, url: &str) -> Option<DownloadType> {
        url.starts_with("http").then_some(DownloadType::Http)
    }
}

pub fn detect_download_type(url: &str) -> Option<DownloadType> {
    let chain: Vec<Box<dyn DownloadTypeDetector>> = vec![
        Box::new(MagnetDetector),
        Box::new(TorrentDetector),
        Box::new(HttpDetector),
    ];
    chain.iter().find_map(|d| d.detect(url))
}
```

**Step 3: Register module in services/mod.rs**

Add `pub mod download_type_detector;`

**Step 4: Run tests**
```bash
cargo test -p core-service download_type_detector
```

**Step 5: Commit**
```bash
git add -A && git commit -m "feat(core): add Chain of Responsibility download type detector"
```

---

### Task 5: Core Service — DownloadDispatchService

**Files:**
- Create: `core-service/src/services/download_dispatch.rs`
- Modify: `core-service/src/services/mod.rs`

**Step 1: Implement DownloadDispatchService**

This service handles:
- Finding capable downloaders for a download_type (DB query via diesel)
- Sending batch download requests to downloader services (HTTP via reqwest)
- Processing results and creating download records
- Cascade logic (retry with next downloader on rejection)
- Retry no_downloader links when new downloader registers

Key methods:
```rust
pub struct DownloadDispatchService {
    db_pool: DbPool,
    http_client: reqwest::Client,
}

impl DownloadDispatchService {
    pub fn new(db_pool: DbPool) -> Self;

    /// Dispatch a batch of new anime_links to appropriate downloaders
    pub async fn dispatch_new_links(&self, link_ids: Vec<i32>) -> Result<DispatchResult, String>;

    /// Find downloaders capable of handling a download_type, sorted by priority DESC
    fn find_capable_downloaders(&self, download_type: &str) -> Result<Vec<ServiceModule>, String>;

    /// Send batch download request to a specific downloader
    async fn send_batch_to_downloader(&self, base_url: &str, items: &[DownloadRequestItem]) -> Result<BatchDownloadResponse, String>;

    /// Retry links with no_downloader status for given download types
    pub async fn retry_no_downloader_links(&self, download_types: &[String]) -> Result<(), String>;
}
```

**Step 2: Verify compilation**
```bash
cargo check -p core-service
```

**Step 3: Commit**
```bash
git add -A && git commit -m "feat(core): add DownloadDispatchService for batch download dispatch with cascade"
```

---

### Task 6: Core Service — Integrate dispatch into fetcher_results handler

**Files:**
- Modify: `core-service/src/handlers/fetcher_results.rs`
- Modify: `core-service/src/state.rs` (add DownloadDispatchService to AppState)
- Modify: `core-service/src/main.rs` (initialize DownloadDispatchService)

**Step 1: Add DownloadDispatchService to AppState**

```rust
pub struct AppState {
    pub db: DbPool,
    pub registry: Arc<ServiceRegistry>,
    pub repos: Arc<Repositories>,
    pub dispatch_service: Arc<DownloadDispatchService>,
}
```

**Step 2: Update receive_raw_fetcher_results**

After all items are processed:
1. Collect link_ids of newly created anime_links (from this batch)
2. Call `dispatch_service.dispatch_new_links(link_ids).await`
3. Log dispatch results

**Step 3: Update process_parsed_result to use detect_download_type**

Set `download_type` field on new anime_link using `detect_download_type(url)`.

**Step 4: Verify compilation**
```bash
cargo check -p core-service
```

**Step 5: Commit**
```bash
git add -A && git commit -m "feat(core): integrate download dispatch into fetcher results pipeline"
```

---

### Task 7: Core Service — Update service registration for downloader capabilities

**Files:**
- Modify: `core-service/src/handlers/services.rs`

**Step 1: Update register() handler**

After UPSERT to service_modules, if service_type is Downloader:
1. Get the module_id of the upserted record
2. DELETE existing capabilities for that module_id
3. INSERT new capabilities from `payload.capabilities.supported_download_types`
4. Call `dispatch_service.retry_no_downloader_links()` for the new types

**Step 2: Verify compilation**
```bash
cargo check -p core-service
```

**Step 3: Commit**
```bash
git add -A && git commit -m "feat(core): save downloader capabilities on registration, trigger no_downloader retry"
```

---

### Task 8: Downloader Service — Rewrite trait and handlers for batch API

**Files:**
- Modify: `downloaders/qbittorrent/src/traits.rs`
- Modify: `downloaders/qbittorrent/src/handlers.rs`
- Modify: `downloaders/qbittorrent/src/qbittorrent_client.rs`
- Modify: `downloaders/qbittorrent/src/mock.rs`
- Modify: `downloaders/qbittorrent/src/main.rs`

**Step 1: Rewrite traits.rs**

Replace current trait with new batch-oriented methods:
- `add_torrents(items: Vec<DownloadItem>) -> Result<Vec<DownloadItemResult>>`
- `cancel_torrents(hashes: Vec<String>) -> Result<Vec<CancelResult>>`
- `query_status(hashes: Vec<String>) -> Result<Vec<DownloadStatusItem>>`
- Keep: `login`, `pause_torrent`, `resume_torrent`, `delete_torrent`
- Remove: `add_magnet`, `add_torrent`, `get_torrent_info`, `get_all_torrents`, `extract_hash_from_magnet`, `extract_hash_from_url`

Note: `extract_hash_from_url` becomes a private helper method on QBittorrentClient, not part of the trait.

**Step 2: Implement new methods in qbittorrent_client.rs**

- `add_torrents`: iterate items, call qBittorrent API for each, collect results
- `cancel_torrents`: call qBittorrent delete API for each hash
- `query_status`: call qBittorrent torrent info API for given hashes

**Step 3: Update mock.rs**

Match new trait interface with configurable return values.

**Step 4: Rewrite handlers.rs**

New handler functions:
- `batch_download` — POST /downloads
- `batch_cancel` — POST /downloads/cancel
- `query_status` — GET /downloads
- Keep: `pause`, `resume`, `delete`, `health_check`

**Step 5: Update main.rs router**

```rust
Router::new()
    .route("/downloads", post(handlers::batch_download::<QBittorrentClient>))
    .route("/downloads", get(handlers::query_download_status::<QBittorrentClient>))
    .route("/downloads/cancel", post(handlers::batch_cancel::<QBittorrentClient>))
    .route("/downloads/:hash/pause", post(handlers::pause::<QBittorrentClient>))
    .route("/downloads/:hash/resume", post(handlers::resume::<QBittorrentClient>))
    .route("/downloads/:hash", delete(handlers::delete_download::<QBittorrentClient>))
    .route("/health", get(handlers::health_check))
```

**Step 6: Verify compilation**
```bash
cargo check -p downloader-qbittorrent
```

**Step 7: Commit**
```bash
git add -A && git commit -m "feat(downloader): rewrite trait and handlers for batch download/cancel/status API"
```

---

### Task 9: Downloader Service — Rewrite all tests

**Files:**
- Modify: `downloaders/qbittorrent/tests/integration/handler_tests.rs`
- Modify: `downloaders/qbittorrent/tests/unit/hash_extraction_tests.rs`
- Possibly modify: `downloaders/qbittorrent/tests/integration/mod.rs`

**Step 1: Rewrite handler_tests.rs for new batch API**

Tests for:
- `test_batch_download_magnets_returns_200`
- `test_batch_download_torrent_urls_returns_200`
- `test_batch_download_empty_items_returns_200`
- `test_batch_cancel_returns_200`
- `test_query_status_returns_200`
- `test_health_check`

**Step 2: Update hash_extraction_tests.rs**

Keep existing tests but adjust for private helper function (test via the batch API instead).

**Step 3: Run all tests**
```bash
cargo test -p downloader-qbittorrent
```

**Step 4: Commit**
```bash
git add -A && git commit -m "test(downloader): rewrite all tests for batch download API"
```

---

### Task 10: Core Service — DownloadScheduler

**Files:**
- Create: `core-service/src/services/download_scheduler.rs`
- Modify: `core-service/src/services/mod.rs`
- Modify: `core-service/src/main.rs` (start scheduler)

**Step 1: Implement DownloadScheduler**

Pattern follows FetchScheduler:
```rust
pub struct DownloadScheduler {
    db_pool: DbPool,
    poll_interval_secs: u64,  // from env DOWNLOAD_POLL_INTERVAL, default 60
    http_client: reqwest::Client,
}

impl DownloadScheduler {
    pub async fn start(self: Arc<Self>) {
        loop {
            tokio::time::sleep(Duration::from_secs(self.poll_interval_secs)).await;
            if let Err(e) = self.poll_all_downloaders().await {
                tracing::error!("Download poll error: {}", e);
            }
        }
    }

    async fn poll_all_downloaders(&self) -> Result<(), String> {
        // 1. Get all enabled downloader modules from DB
        // 2. For each: get downloading hashes, query status, update DB
        // 3. On connection failure: mark as downloader_error
        // 4. On recovery: re-query and update to actual status
    }
}
```

**Step 2: Start in main.rs**

```rust
let download_scheduler = Arc::new(DownloadScheduler::new(app_state.db.clone()));
let ds_clone = download_scheduler.clone();
tokio::spawn(async move { ds_clone.start().await; });
```

**Step 3: Verify compilation**
```bash
cargo check -p core-service
```

**Step 4: Commit**
```bash
git add -A && git commit -m "feat(core): add DownloadScheduler for periodic download status polling"
```

---

### Task 11: Downloader Service — Update startup registration

**Files:**
- Modify: `downloaders/qbittorrent/src/main.rs`

**Step 1: Update registration payload**

Add `supported_download_types: vec![DownloadType::Magnet, DownloadType::Torrent]` to the Capabilities in the registration request.

**Step 2: Verify compilation**
```bash
cargo check -p downloader-qbittorrent
```

**Step 3: Commit**
```bash
git add -A && git commit -m "feat(downloader): declare supported download types during registration"
```

---

### Task 12: Final verification and formatting

**Step 1: Format all code**
```bash
cargo fmt --all
```

**Step 2: Check all packages compile**
```bash
cargo check --workspace
```

**Step 3: Run all tests**
```bash
cargo test -p downloader-qbittorrent
cargo test -p core-service -- download_type_detector
```

**Step 4: Final commit**
```bash
git add -A && git commit -m "style: cargo fmt"
```
